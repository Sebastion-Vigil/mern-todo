### Initial Observations: ###

 #### Unique Highlights: ####
 - react hooks! yay!
 - react-router6+
 - react-query => like jquery? research & learn 2 use with the quickness!
 - vite instead of create-react-app 
 - lodash, pkg o' f() 4 iterating arrs, objs, strs, slicing & dicing! 

 #### Client: ####
  - npm run dev -> start up front end in dev mode
  - no public folder -> index.html just out there
  - using .jsx files, e.g., App.jsx => research this online (pros/cons)
  - main.jsx file replaces traditional (2 me, at least ";-)") index.js file
  - vite -> used instead of create-react-app => research this online (how 2 use, duh!)

 #### Server ####
  - i C .js files, e.g., the good ol' traditional index.js file!
   - research Y set up this way compared to .jsx files, e.g., main.jsx in client

### Other ###
 #### Fix NPM Security Vulnerabilities ####
 - https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities

 ##### Idea #####
 - build learn to code website for juveniles, teens, and young adults
 - teach them computer science concepts wrapped around the tangible experience of building a web app
 - make free, engaging, fun
 - break down Time Complexity and Big O Notation using simple experiences/ideas that they can relate to.
   - e.g., Explain Big O Notation and Time Complexity using an analogy of bussing tables in a restaurant
   - Contrast Time Complexity to a speedomoter in a car; a speedometer is a set measure of a car's current speed,
   - A speedometer quantifies the velocity of a car; Time Complexity quantifies the efficiency of an algorithm.
   - An Algorithm is a fancy word for a process, and literally anything can be broken down into a process. Time complexity is a measurement, or quantification of how efficiently you perform that process, or algorithm.
   - whereas Time Complexity measures the efficiency of an algorithm, i.e., how many data points you must hit
   - (use the bussing analogy => say there are 10 tables in your work area, and for each table, you have a set goal, to completely reset the table so that more customores can be sat. ) You want to work as efficiently as possible, to avoid unnecessary repetition. Understanding Time Complexity gives you a way to measure, or quantify, the efficiency with which you bus tables at work, and you annote this quantification with something called Big O Notation. Your entire work area, let's suppose a section of 10 tables, could be called your Data Set.  Each time you go to a table, even if it's the same table multiple times, could be called a data point. The sum of the total number of trips you make to your tables at work are your total number of data points. So now that you know what your data set is, and what your data points are, let's explain this with Big O Notation so you can see how it works. Suppose that you are so good at bussing tables that you only have to make one single trip to each table to completely reset it, that is, you walk up a dirty table, and walk away leaving a clean table ready for more customers to sit down eat! Your Time Complexity, or the efficiency of your work, would be annotated as O(n), meaning that you have ten tables and only have to hit each table once, or only have to hit 10 data points

   First, you must realize that, in contrast to the speedometer of the car you drove to work, 
   - When you drove to work today, your's car's speedometer measured how fast you were going. To measure the efficiency of how you bus tables at your job,

##### Link to Time Complexity With Simple Examples #####
 - https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/